#!/usr/bin/env ruby

# TODO Turn this into a set of RSpec tests

target = File.dirname(__FILE__) + '/../lib'
$:.unshift(target) unless $:.include?(target) || $:.include?(File.expand_path(target))

require 'gecos/word'
require 'gecos/array'

WORD_FORMAT = '%012o'
DEFAULT_FORMAT = '%p'

def format_collection(obj, name, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  collection = protected_send(obj, name)
  new_obj = collection.class.new
  size = options[:size] || collection.size
  indexes = collection.is_a?(Hash) ? collection.keys : (0...size)
  indexes.inject(new_obj) do |coll, index|
    coll[index] = format % [collection[index]]
    coll
  end
end

def format_method(obj, name, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  collection = protected_send(obj, name + 's')
  new_obj = collection.class.new
  size = options[:size] || collection.size
  indexes = collection.is_a?(Hash) ? collection.keys : (0...size)
  indexes.inject(new_obj) do |coll, index|
    value = protected_send(obj, name, index)
    coll[index] = format % [value]
    coll
  end
end

def format_collection_table(obj, name, options={})
  options = options.merge(:collection=>true) unless options[:collection] || options[:method]
  collection = format_collection(obj, name+"s", options)
  size = options[:size] || collection.size
  indexes = collection.is_a?(Hash) ? collection.keys.sort_by{|k| k.to_s} : (0...size)
  methods = format_method(obj, name, options)
  table = indexes.map do |k| 
    row = [k.inspect]
    row << collection[k] if options[:collection] || options[:both]
    row << methods[k]    if options[:method] || options[:both]
    row
  end
  key_heading = collection.is_a?(Hash) ? 'key' : 'n'
  heading = [key_heading]
  heading << name+"s[#{key_heading}]" if options[:collection] || options[:both]
  heading << name+"(#{key_heading})"  if options[:method] || options[:both]
  table.unshift(heading)
  table.justify_rows
end

class Exception
  def formatted_trace
    backtrace.map{|line| "        from " + line}.join("\n")
  end
end

def protected_send(obj, *args, &blk)
  meth = args.shift
  obj.send(meth, *args, &blk)
rescue => e
  raise e.class, "Unable to retrieve #{meth}(#{args.map{|a| a.inspect}.join(',')}) for #{obj.inspect}: #{e}\n#{e.formatted_trace}\n\n"
end

def protected_eval(*args)
  code = args.first
  eval(*args)
rescue => e
  raise e.class, "Unable to eval #{code}: #{e}\n#{e.formatted_trace}\n\n"
end

def verify_collection_and_method(obj, name, options={})
  return true if format_collection(obj, name+'s', :format=>'%p') == format_method(obj, name, :format=>'%p')
  puts "*** #{obj.inspect} #{name} collection != method results" unless options[:quiet]
  return false
end

# Move this table stuff to a separate Gem
def put_table(table)
  table.each {|row| puts row.join('  ') }
end

# Splice two tables side-by-side
def splice_table(*tables)
  table = tables.shift
  tables.each do |new_table|
    table.each_with_index do |row, i|
      table[i] = row + new_table[i]
    end
  end
  table
end

def shift_table(table)
  table.map{|row| row.shift; row}
end

def show_collection(obj, name, options={})
  put_table format_collection_table(obj, name, options)
end

def show_slice_collection(word, slice, parameter, options={})
  slices = slice.pluralize
  size = protected_send(word, "#{slices}_per_word")
  puts "#{slices}_per_word = #{size.inspect}"
  name = [slice, parameter].join('_')
  show_collection(word, name, options)
end

def show_value(expression, options={})
  format = options[:format] || '%p'
  val = protected_eval(expression, options[:binding])
  puts "#{expression} => #{format % [val]}"
end

def show_slice_parameter(word, slice, parameter)
  show_value "word.#{slice}.#{parameter}", :binding=>binding
end

def show_slice_class_parameter(slice, parameter, options={})
  klass_name = class_name(slice)
  show_value "#{klass_name}.#{parameter}", options
end

def show_word_class_parameter(name, options={})
  show_value "GECOS::Word.#{name}", options
end

def get_slice_class_parameter(slice, parameter, options={})
  klass_name = class_name(slice)
  format = options[:format] || '%p'
  klass = protected_eval(klass_name)
  format % protected_send(klass, parameter)
end

def class_name(slice)
  "GECOS::Word::" + slice.to_s.gsub(/(^|_)(.)/) {|match| $2.upcase}
end

def show_slice_class_parameters(slice, parameter_list, options={})
  klass_name = class_name(slice)
  table = parameter_list.map do |parameter|
    format = nil
    if parameter =~ /\s*\((.*)\)$/
      parameter = $`
      format = $1
      options = options.merge(:format=>format)
    end
    [parameter] + [get_slice_class_parameter(slice, parameter, options)]
  end
  puts klass_name + ":"
  table.unshift ["Parameter", klass_name]
  table = table.justify_rows
  put_table table
end

def format_class_collection(name, options={})
  format_collection_table(GECOS::Word, name, {:format=>WORD_FORMAT}.merge(options))
end

def show_class_collection(name, options={})
  puts "GECOS::Word.#{name}:"
  table = format_class_collection(name, options)
  put_table table
end

def format_slice_class_collection(slice, name, options={})
  klass_name = class_name(slice)
  klass = protected_eval(klass_name)
  format_collection_table(klass, name, options)
end

def format_slice_class_formats(slice, options={})
  klass_name = class_name(slice)
  klass = protected_eval(klass_name)
  format_collection_table(klass, "format_type", options)
  table = []
  table << ['n', 'format_types(n)', 'format_definitions[key]']
  klass.format_types.each_with_index do |format, n|
    table << [n, format.inspect, klass.format_definition(format).inspect]
  end
  table.justify_rows
end

def show_slice_class_collection(slice, name, options={})
  put_table format_slice_class_collection(slice, name, options)
end

def show_word_slice(word, slice, options={})
  slices = slice.to_s.pluralize
  binding = options[:binding]
  klass_name = class_name(slice)
  has_string = protected_eval("#{klass_name}.string?")
  show_value "#{word}.#{slices}", :binding=>binding
  collection = protected_eval("#{word}.#{slices}", binding)
  show_value "#{word}.#{slices}.string", :binding=>binding if has_string
  table = []
  formats = protected_eval("#{klass_name}.format_types")
  heading = ["n", "value"] + formats.map{|f| f.inspect }
  heading << "string" if has_string
  table << heading
  collection.each_with_index do |byte, n|
    s="#{word}.#{slice}[#{n}]"
    value = protected_eval("#{word}.#{slice}[#{n}]", binding)
    row = [n, WORD_FORMAT % [value]]
    row += formats.map do |format|
      protected_eval("#{word}.#{slice}(#{n}).format(#{format.inspect})", binding)
    end
    row << protected_eval("#{word}.#{slice}(#{n}).string", binding) if has_string
    table << row
  end
  table = table.justify_rows
  table.each {|row| puts row.join('  ')}
end

def format_collections(obj, list, options={})
  tables = list.map do |t|
    format = options[:format] && (options[:format].is_a?(Hash) ? options[:format][t] : options[:format])
    format_collection_table(obj, t, options.merge(:format=>format))
  end
  (1...tables.size).each {|i| tables[i] = shift_table(tables[i]) }
  splice_table(*tables)
end

def show_collections(obj_name, list, options={})
  obj = protected_eval(obj_name)
  put_table format_collections(obj, list, options)
end

def show_word(expr)
  show_value "#{expr}.value", :format=>WORD_FORMAT
  GECOS::Word.slice_names.sort_by{|n| n.to_s}.each do |slice|
    show_word_slice expr, slice
    puts
  end
end

MASKS = %w{single_bit_mask ones_mask}

puts "GECOS::Word:"
show_value "GECOS::Word.size"
show_value "GECOS::Word.ones_mask", :format=>WORD_FORMAT
show_collections "GECOS::Word", MASKS, :format=>WORD_FORMAT, :size=>GECOS::Word.size+1
puts

GECOS::Word.slice_names.sort_by{|n| n.to_s}.each do |slice|
  show_slice_class_parameters slice, %w{size offset count significant_bits mask(%#012o) string?(%p)}
  puts
  
  # start_bit_table  = format_slice_class_collection slice, "start_bit"
  # end_bit_table    = format_slice_class_collection slice, "end_bit"
  # shift_bits_table = format_slice_class_collection slice, "shift"
  # mask_table       = format_slice_class_collection slice, "mask", :format=>WORD_FORMAT
  # put_table splice_table(start_bit_table, shift_table(end_bit_table), shift_table(shift_bits_table), shift_table(mask_table))
  # puts
  
  # show_collections class_name(slice), MASKS, :format=>WORD_FORMAT
  
  put_table format_slice_class_formats(slice)
  puts
end

$byte_test_word = GECOS::Word.new(0111222333444)
$negative = GECOS::Word.new(0777777777777)

show_word "$byte_test_word"
show_word "$negative"

# Does arithmetic work?
show_value "$byte_test_word-5", :format=>WORD_FORMAT
show_value "3+$byte_test_word", :format=>WORD_FORMAT
show_value "$byte_test_word.packed_characters.string"

# Does string manipulation work?
show_value "'First character: '+($byte_test_word.character(0))"
show_value "$byte_test_word.character(0)+': is here'"
show_value "$byte_test_word.character(0).add(2)"

# Test signed integers
show_value "$negative.integer(0).signed"
show_value "$negative.integer(0).unsigned", :format=>'%012o'

# Formatting methods
show_value "$byte_test_word.byte(2).octal"
show_value "$negative.integer(0).decimal"
show_value "$negative.integer.decimal"
show_value "$negative.integer(0).unsigned.octal"
show_value "$negative.integer.signed.hex"

$words = GECOS::Words[1,2,3]
show_value "$words.class"
show_value "$words"
show_value "$words.size"
show_value "$words[0]"
show_value "$words[0].class"
$words[5] = 1234
show_value "$words"
show_value "$words[4]"
show_value "$words[5]"
show_value "$words[2..3]"
show_value "$words[2..3].bytes"
show_value "$words[2..3].byte(3)"
show_value "$words[2..3].byte(4)"
