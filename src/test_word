#!/usr/bin/env ruby
target = File.dirname(__FILE__) + '/../lib'
$:.unshift(target) unless $:.include?(target) || $:.include?(File.expand_path(target))

require 'gecos/word'
require 'pp'

# TODO Move this to a Gem
class Array
  # Take an array of columns and justify each column so that they're all the same width
  def justify_columns
    widths = self.map do |column|
      column.map{|entry| entry.to_s.size}.max
    end
    justified = []
    self.each_with_index do |column, column_number|
      justified << column.map{|entry| "%-#{widths[column_number]}s" % [entry] }
    end
    justified
  end
  
  # Take an array of rows and justify them so each column is all the same width
  def justify_rows
    self.transpose.justify_columns.transpose
  end
end

WORD_FORMAT = '%012o'
DEFAULT_FORMAT = '%p'

def format_array(obj, name, options={})
  format_hash(obj, name, options)
  # format = options[:format] || DEFAULT_FORMAT
  # name = name.to_s.downcase
  # array = obj.send(name)
  # (0...array.size).map {|n| format % (array[n]) }
end

def format_hash(obj, name, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  hash = obj.send(name)
  new_obj = hash.class.new
  indexes = hash.is_a?(Hash) ? hash.keys : (0...hash.size)
  indexes.inject(new_obj) do |hsh, key|
    hsh[key] = format % [hash[key]]
    hsh
  end
end

def dump_array(obj, name, options={})
  name = name.to_s.downcase
  format_array(obj, name, options).each_with_index do |s, n|
    puts "#{name}[#{n}] = #{s}"
  end
end

def format_method(obj, name, size, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  (0...size).map {|n| format % [obj.send(name, n)] }
end

def format_method_hash(obj, name, keys, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  keys.inject({}) do |hsh, key|
    hsh[key] = format % [obj.send(name, key)]
    hsh
  end
end

def dump_method(obj, name, size, options={})
  name = name.to_s.downcase
  format_method(obj, name, size, options).each_with_index do |s, n|
    puts "#{name}(#{n}) = #{s}"
  end
end

def dump_array_parameter(obj, name, options={})
  array = format_array(obj, name+"s", options)
  size = array.size
  ns = (0...size).to_a
  methods = format_method(obj, name, size, options)
  table = ns.zip(array, methods)
  table.unshift(["n", name+'s[n]', name+'(n)']) # Add heading
  table = table.justify_rows
  table.each {|row| puts row.join("  ")}
end

def dump_hash_parameter(obj, name, options={})
  hash = format_hash(obj, name+"s", options)
  size = hash.size
  keys = hash.keys
  methods = format_method_hash(obj, name, keys, options)
  table = keys.sort_by{|key| key.to_s}.map {|k| [k.inspect, hash[k], methods[k]] }
  table.unshift(["key", name+'s[key]', name+'(key)']) # Add heading
  table = table.justify_rows
  table.each {|row| puts row.join("  ")}
end

def dump_slice_array_parameter(word, slice, parameter, options={})
  size = word.send("#{slice}s_per_word")
  puts "#{slice}s_per_word = #{size.inspect}"
  name = [slice, parameter].join('_')
  dump_array_parameter(word, name, options)
end

def dump_value(expression, options={})
  binding = options[:binding] || self.send(:binding)
  format = options[:format] || '%p'
  STDOUT.flush
  STDERR.flush
  val = begin
    eval(expression, binding)
  rescue => e
    raise RuntimeError, "dump_value failed: #{e}"
  end
  puts "#{expression} => #{format % [val]}"
end

def dump_slice_parameter(word, slice, parameter)
  dump_value "word.#{slice}.#{parameter}", :binding=>binding
end

def dump_slice_class_parameter(slice, parameter, options={})
  klass_name = class_name(slice)
  dump_value "#{klass_name}.#{parameter}", options
end

def dump_word_class_parameter(name, options={})
  dump_value "Gecos::Word.#{name}", options
end

def get_slice_class_parameter(slice, parameter, options={})
  klass_name = class_name(slice)
  if parameter =~ /^\((.*)\)/
    word_class_parameter = "#{slice}#{$1}#{$'}"
    slice_class_parameter = $'
  else
    word_class_parameter = "#{slice}_#{parameter}"
    slice_class_parameter = parameter
  end
  format = options[:format] || '%p'
  [Gecos::Word.send(word_class_parameter), eval(klass_name).send(slice_class_parameter)].map{|e| format % [e]}
end

def class_name(slice)
  "Gecos::Word::" + slice.to_s.gsub(/(^|_)(.)/) {|match| $2.upcase}
end

def dump_slice_class_parameters(slice, parameter_list, options={})
  klass_name = class_name(slice)
  table = parameter_list.map do |parameter|
    format = nil
    if parameter =~ /\s*\((.*)\)$/
      parameter = $`
      format = $1
      options = options.merge(:format=>format)
    end
    [parameter] + get_slice_class_parameter(slice, parameter, options)
  end
  puts klass_name + ":"
  table.unshift ["Parameter", "Gecos::Word", klass_name]
  table.justify_rows.each do |row|
    puts row.join('  ')
  end
end

def dump_class_array_parameter(name, options={})
  puts "Gecos::Word.#{name}:"
  dump_array_parameter(Gecos::Word, name, options)
end

def dump_slice_class_array_parameter(slice, name, options={})
  klass_name = class_name(slice)
  klass = eval(klass_name)
  dump_array_parameter(klass, name, options)
end

def dump_slice_class_hash_parameter(slice, name, options={})
  klass_name = class_name(slice)
  klass = eval(klass_name)
  dump_hash_parameter(klass, name, options)
end

dump_value "Gecos::Word.size"
dump_value "Gecos::Word.all_ones", :format=>WORD_FORMAT
dump_class_array_parameter "single_bit_mask",    :format=>WORD_FORMAT
dump_class_array_parameter "preceding_bit_mask", :format=>WORD_FORMAT
dump_class_array_parameter "following_bit_mask", :format=>WORD_FORMAT
dump_class_array_parameter "n_bit_mask",         :format=>WORD_FORMAT
dump_class_array_parameter "lower_bit_mask",     :format=>WORD_FORMAT
dump_class_array_parameter "upper_bit_mask",     :format=>WORD_FORMAT
puts

%w{half_word byte character packed_character}.each do |slice|
  dump_slice_class_parameters slice, %w{size offset (s_)per_word clipping_mask(0%3o)}
  dump_slice_class_array_parameter slice, "start_bit"
  dump_slice_class_array_parameter slice, "end_bit"
  dump_slice_class_array_parameter slice, "shift"
  dump_slice_class_array_parameter slice, "mask", :format=>WORD_FORMAT
  dump_slice_class_hash_parameter slice, "format_string"
  puts
end

bytes = Gecos::Word.new(0111222333444)
dump_value "bytes.value", :binding=>binding, :format=>WORD_FORMAT
puts "bytes.bytes is a #{bytes.bytes.class}"
dump_value "bytes.bytes", :binding=>binding
bytes.bytes.each_with_index do |byte, n|
  dump_value "bytes.byte(#{n}).value", :binding=>binding, :format=>WORD_FORMAT
end
