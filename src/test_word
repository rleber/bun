#!/usr/bin/env ruby
target = File.dirname(__FILE__) + '/../lib'
$:.unshift(target) unless $:.include?(target) || $:.include?(File.expand_path(target))

require 'gecos/word'
require 'gecos/array'

WORD_FORMAT = '%012o'
DEFAULT_FORMAT = '%p'

def format_collection(obj, name, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  collection = protected_send(obj, name)
  new_obj = collection.class.new
  indexes = collection.is_a?(Hash) ? collection.keys : (0...collection.size)
  indexes.inject(new_obj) do |coll, index|
    coll[index] = format % [collection[index]]
    coll
  end
end

def format_method(obj, name, options={})
  format = options[:format] || DEFAULT_FORMAT
  name = name.to_s.downcase
  collection = protected_send(obj, name + 's')
  new_obj = collection.class.new
  indexes = collection.is_a?(Hash) ? collection.keys : (0...collection.size)
  indexes.inject(new_obj) do |coll, index|
    value = protected_send(obj, name, index)
    coll[index] = format % [value]
    coll
  end
end

def format_collection_table(obj, name, options={})
  options= options.merge(:both=>true) unless verify_collection_and_method(obj, name)
  options = options.merge(:collection=>true) unless options[:collection] || options[:method]
  collection = format_collection(obj, name+"s", options)
  size = collection.size
  indexes = collection.is_a?(Hash) ? collection.keys.sort_by{|k| k.to_s} : (0...size)
  methods = format_method(obj, name, options)
  table = indexes.map do |k| 
    row = [k.inspect]
    row << collection[k] if options[:collection] || options[:both]
    row << methods[k]    if options[:method] || options[:both]
    row
  end
  key_heading = collection.is_a?(Hash) ? 'key' : 'n'
  heading = [key_heading]
  heading << name+"s[#{key_heading}]" if options[:collection] || options[:both]
  heading << name+"(#{key_heading})"  if options[:method] || options[:both]
  table.unshift(heading)
  table.justify_rows
end

class Exception
  def formatted_trace
    backtrace.map{|line| "        from " + line}.join("\n")
  end
end

def protected_send(obj, *args, &blk)
  meth = args.shift
  obj.send(meth, *args, &blk)
rescue => e
  raise RuntimeError, "Unable to retrieve #{meth}(#{args.map{|a| a.inspect}.join(',')}) for #{obj.inspect}: #{e}\n#{e.formatted_trace}\n\n"
end

def protected_eval(*args)
  code = args.first
  eval(*args)
rescue => e
  raise RuntimeError, "Unable to eval #{code}: #{e}\n#{e.formatted_trace}\n\n"
end

def verify_collection_and_method(obj, name, options={})
  return true if format_collection(obj, name+'s', :format=>'%p') == format_method(obj, name, :format=>'%p')
  puts "*** #{obj.inspect} #{name} collection != method results" unless options[:quiet]
  return false
end

# Move this table stuff to a separate Gem
def put_table(table)
  table.each {|row| puts row.join('  ') }
end

# Splice two tables side-by-side
def splice_table(*tables)
  table = tables.shift
  tables.each do |new_table|
    table.each_with_index do |row, i|
      table[i] = row + new_table[i]
    end
  end
  table
end

def shift_table(table)
  table.map{|row| row.shift; row}
end

def show_collection(obj, name, options={})
  put_table format_collection_table(obj, name, options)
end

def show_slice_collection(word, slice, parameter, options={})
  size = protected_send(word, "#{slice}s_per_word")
  puts "#{slice}s_per_word = #{size.inspect}"
  name = [slice, parameter].join('_')
  show_collection(word, name, options)
end

def show_value(expression, options={})
  format = options[:format] || '%p'
  STDOUT.flush
  STDERR.flush
  val = protected_eval(expression, options[:binding]||binding)
  puts "#{expression} => #{format % [val]}"
end

def show_slice_parameter(word, slice, parameter)
  show_value "word.#{slice}.#{parameter}", :binding=>binding
end

def show_slice_class_parameter(slice, parameter, options={})
  klass_name = class_name(slice)
  show_value "#{klass_name}.#{parameter}", options
end

def show_word_class_parameter(name, options={})
  show_value "Gecos::Word.#{name}", options
end

def get_slice_class_parameter(slice, parameter, options={})
  klass_name = class_name(slice)
  if parameter =~ /^\((.*)\)/
    word_class_parameter = "#{slice}#{$1}#{$'}"
    slice_class_parameter = $'
  else
    word_class_parameter = "#{slice}_#{parameter}"
    slice_class_parameter = parameter
  end
  format = options[:format] || '%p'
  klass = protected_eval(klass_name)
  [protected_send(Gecos::Word, word_class_parameter), protected_send(klass, slice_class_parameter)].map{|e| format % [e]}
end

def class_name(slice)
  "Gecos::Word::" + slice.to_s.gsub(/(^|_)(.)/) {|match| $2.upcase}
end

def show_slice_class_parameters(slice, parameter_list, options={})
  klass_name = class_name(slice)
  table = parameter_list.map do |parameter|
    format = nil
    if parameter =~ /\s*\((.*)\)$/
      parameter = $`
      format = $1
      options = options.merge(:format=>format)
    end
    [parameter] + get_slice_class_parameter(slice, parameter, options)
  end
  puts klass_name + ":"
  table.unshift ["Parameter", "Gecos::Word", klass_name]
  table = table.justify_rows
  put_table table
end

def format_class_collection(name, options={})
  format_collection_table(Gecos::Word, name, options)
end

def show_class_collection(name, options={})
  puts "Gecos::Word.#{name}:"
  table = format_class_collection(name, options)
  put_table table
end

def format_slice_class_collection(slice, name, options={})
  klass_name = class_name(slice)
  klass = protected_eval(klass_name)
  format_collection_table(klass, name, options)
end

def show_slice_class_collection(slice, name, options={})
  put_table format_slice_class_collection(slice, name, options)
end

def show_word_slice(word, slice, options={})
  binding = options[:binding] || binding
  klass_name = class_name(slice)
  has_string = protected_eval("#{klass_name}.string?")
  show_value "#{word}.#{slice}s", :binding=>binding
  collection = protected_eval("#{word}.#{slice}s", binding)
  show_value "#{word}.#{slice}s.merge", :binding=>binding if has_string
  table = []
  formats = protected_eval("#{klass_name}.format_types")
  heading = ["n", "value"] + formats.map{|f| f.inspect }
  heading << "string" if has_string
  table << heading
  collection.each_with_index do |byte, n|
    value = protected_eval("#{word}.#{slice}(#{n}).value", binding)
    row = [n, WORD_FORMAT % [value]]
    row += formats.map do |format|
      protected_eval("#{word}.#{slice}(#{n}).format(#{format.inspect})", binding)
    end
    row << protected_eval("#{word}.#{slice}(#{n}).string.inspect", binding) if has_string
    table << row
  end
  table = table.justify_rows
  table.each {|row| puts row.join('  ')}
end

show_value "Gecos::Word.size"
show_value "Gecos::Word.all_ones", :format=>WORD_FORMAT
puts "Gecos::Word:"
single_bit_mask_table    = format_class_collection "single_bit_mask",    :collection=>true, :format=>WORD_FORMAT
preceding_bit_mask_table = format_class_collection "preceding_bit_mask", :collection=>true, :format=>WORD_FORMAT
following_bit_mask_table = format_class_collection "following_bit_mask", :collection=>true, :format=>WORD_FORMAT
n_bit_mask_table         = format_class_collection "n_bit_mask",         :collection=>true, :format=>WORD_FORMAT
lower_bit_mask_table     = format_class_collection "lower_bit_mask",     :collection=>true, :format=>WORD_FORMAT
upper_bit_mask_table     = format_class_collection "upper_bit_mask",     :collection=>true, :format=>WORD_FORMAT
put_table splice_table(single_bit_mask_table, 
  shift_table(preceding_bit_mask_table), 
  shift_table(following_bit_mask_table), 
  shift_table(n_bit_mask_table),
  shift_table(lower_bit_mask_table),
  shift_table(upper_bit_mask_table)
)
puts

Gecos::Word.slice_names.sort_by{|n| n.to_s}.each do |slice|
  show_slice_class_parameters slice, %w{size offset (s_)per_word significant_bits clipping_mask(%#012o) string?(%p)}
  puts
  
  start_bit_table  = format_slice_class_collection slice, "start_bit"
  end_bit_table    = format_slice_class_collection slice, "end_bit"
  shift_bits_table = format_slice_class_collection slice, "shift"
  mask_table       = format_slice_class_collection slice, "mask", :format=>WORD_FORMAT
  put_table splice_table(start_bit_table, shift_table(end_bit_table), shift_table(shift_bits_table), shift_table(mask_table))
  puts
  
  # TODO Show slice-specific bit masks
  
  format_type_table = format_slice_class_collection slice, "format_type"
  format_string_table = format_slice_class_collection slice, "format_string"
  format_width_table  = format_slice_class_collection slice, "format_width"
  put_table splice_table(format_type_table, format_string_table, shift_table(format_width_table))
  puts
end

$bytes = Gecos::Word.new(0111222333444)

show_value "$bytes.value", :format=>WORD_FORMAT
Gecos::Word.slice_names.sort_by{|n| n.to_s}.each do |slice|
  show_word_slice "$bytes", slice
  puts
end

# Does arithmetic work?
show_value "$bytes-5", :format=>WORD_FORMAT
show_value "3+$bytes", :format=>WORD_FORMAT

# Does string manipulation work?
show_value "'First character: '+($bytes.character(0))"
show_value "$bytes.character(0)+': is here'"
show_value "$bytes.character(0).add(2)"

# Test signed integers
$negative = Gecos::Word.new(0777777777777)
show_value "$negative.integer(0).signed"
show_value "$negative.integer(0).unsigned", :format=>'%012o'