# Treetop grammar for Roff input lines
# Compile using:
#   tt lib/bun/roff/expand.treetop -o lib/bun/roff/expand_treetop_parser.rb

# This grammar is finicky; mess with it at your peril

# Future enhancement:
#   - Recognize .requests
#   - Set value of numbers to integer value
#   - Store position range
#   - Recognize trailing sentence endings?

grammar RoffInput
	rule input
  	content:(request / line) 1..1
  	{
  		def expand
  			content.elements.first.expand
			end
  	}
	end

  rule request
  	request_word line
  	{
  		def expand
  			request_word.expand + line.expand
			end
  	}
	end

	rule request_word
  	command_character word
  	{
  		def expand
  			[{type: :request_word, value: text_value}]
			end
  	}
	end

	rule command_character
		"."
	end

	rule line
		content:(sentence_part*) end_of_line
		{
			def expand
				content.elements.flat_map{|e| e.expand}
			end
		}
	end

	rule sentence_part
		(register_reference / nested_sentence_part / paren / other_character) 1..1
		{
			def expand
				elements.first.expand
			end
		}
	end

	rule paren
		('(' / ')') 1..1
		{
			def expand
				[{type: :other, value: text_value}]
			end
		}
	end

  rule quoted_string
    quote_character quoted_string_atom* quote_character
    {
    	def expand
    		[{type: :quoted_string, value: text_value}]
    	end
    }
  end

  rule quoted_string_atom
  	escaped_quote / non_quote_character
	end

	rule escaped_quote
		quote_character quote_character
	end

	rule non_quote_character
		!quote_character !end_of_line .
	end

	# For future enhancement: Roff lets you change the quote character
  rule quote_character
  	'"'
  end

	rule register_reference
		'(' word ')'
		{
			def expand
				res = [{type: :register_reference, value: word.expand[0][:value]}]
			end
		}
	end

	rule number
		[0-9]+
		{
			def expand
				[{type: :number, value: text_value}]
			end
		}
	end

	rule word
		# Actually, should be less than 32 characters; lets leave that to the semantics engine
	  [a-zA-Z#%_] ([a-zA-Z0-9#%_] / hyphenation_character)*
	  {
	  	def expand
	  		[{type: :word, value: text_value}]
  		end
	  }
  end

	rule parameter
		parameter_character number
		{
			def expand
	  		[{type: :parameter, value: text_value}]
  		end
		}
	end

	# For future enhancement: Roff lets you change the parameter control character
	rule parameter_character
	  '@'
	end

	rule escape
		insertion_character !('(' / end_of_line) .
		{
			def expand
				[{type: :escape, value: text_value}]
			end
		}
	end

  rule insertion
    insertion_character '(' nested_sentence ')' 
    {
    	def expand
    		[{type: :insertion, value: nested_sentence.expand}]
  		end
    }
	end

	rule parenthesized_sentence
		'(' nested_sentence ')'
		{
			def expand
				[{type: :parenthesized_sentence, value: nested_sentence.expand}]
			end
		}
	end

	rule nested_sentence
		(nested_sentence_parts)
		{
			def expand
				nested_sentence_parts.expand
			end
		}
	end

	rule nested_sentence_parts
		first:nested_sentence_part remainder:nested_sentence_part*
		{
			def expand
				first.expand + remainder.elements.flat_map {|e| e.expand}
			end
		}
	end

	rule nested_sentence_part
		( parenthesized_sentence / nested_sentence_atom ) 1..1
		{
			def expand
				elements.first.expand
			end
		}
	end

	rule nested_sentence_atom
		(whitespace / quoted_string / number / word / parameter / escape / insertion / operator ) 1..1
		{
			def expand
				elements.first.expand
			end
		}
	end

	# For future enhancement: Roff lets you change the insertion control character
	rule insertion_character
		'^'
		{
			def expand
				[{type: :insertion_character, value: text_value}]
			end
		}
	end

	# For future enhancement: Roff doesn't automatically enable this, and allows you to change it
	rule hyphenation_character
		"`"
		{
			def expand
				[{type: :hyphenation_character, value: text_value}]
			end
		}
	end

	rule whitespace
		( [ \t] )+ 
		{
			def expand
				[{type: :whitespace, value: text_value}]
			end
		}
	end

	rule end_of_line
		"\n" 
		{
			def expand
				[{type: :end_of_line, value: text_value}]
			end
		}
	end

	rule operator
		[-+*/<=>]
		{
			def expand
				[{type: :operator, value: text_value}]
			end
		}
	end

  rule other_character
  	(!(insertion_character / quote_character / parameter_character / hyphenation_character / [-()a-zA-Z0-9%#_+*/<=> \t\n] )
  	     .) 1..1
  	{
  		def expand
  			[{type: :other, value: text_value}]
			end
  	}
	end
end
