


........
fass
























.so roffinit
.sp15   
.ce 
.bf 
Implementing Recursive Coroutines   
.sp35   
.ta 60r 
CS 442/642	D R Forster  
Programming Languages	I D Allen 
Prof. F W Tompa	^(amon) ^(day), 19^(year)   
.pa1
.he ""Implementing Recursive Coroutines""   
.fo "CS 442"- % -"CS 642"   
.ds 
.h0 "Introduction"  
.pb 
In the production of this report, it became obvious that there was  
a fundamental difference in the way one treats the implementation   
of recursive coroutines in block-structured languages, and in languages 
which have only one non-local referencing environment.  
The block structure of languages such as ALGOL-60 affects the   
implementation of any kind of subprogramme call so much that it 
becomes necessary to consider the block structuring as the driving force
behind the entire implementation.   
On the other hand, languages having only one non-local referencing  
environment allow for much greater freedom. 
.pb 
This report is therefore divided into two sections along the above lines.   
In the section on block-structured languages, a method is illustrated   ....which allows the user to

which allows the user to use coroutines quite flexibly while still  
providing a protected environment in which the programmes may be run.   
The section on languages having only global and local referencing   
suggests an implementation similar to the one currently implemented at the  
University of Waterloo for the language 'B'.
.h0 "Global-Local~Referencing~Environments" 
.pb 
As Pratt points out, coroutines are conceptually all at the same lexical
level, ie. no 'caller' exists, per se.  
This means that any routine may call any other routine, and this in 
any order.  
The semantic interpretation of a coroutine call / resume is thus obvious.   
When a coroutine is called, a new invocation of that procedure is generated,
which creates a new stack for the local environment of the coroutine
and starts the coroutine off at the beginning of the code   
for that coroutine. 
A resume causes the current instruction counter to be stored in the current stack,  
looks for an invocation of the named coroutine, 
changes the current stack to be that of the coroutine to be resumed,
determines at what address execution was last suspended,
and then resumes execution at that point.   
.pb 
A resume to a coroutine which has not yet been called could be interpreted  
as either an error, or as an implicit call to the routine.  
Here we favour the error interpretation, since a coroutine call 
automatically passes arguments to a coroutine, whereas a resume 
can take no arguments.  
A return should be identical to a resume, with the exception that in
the process of resuming, the stack of the current coroutine and 
all information associated with it should be destroyed, if  
possible.   
.pb 
The question of recursion now arises.   
While it is not as serious a problem as for block structured languages, 
it is a problem.
There are two schema for interpreting successive calls to a coroutine:  
.ls1
.li 
References to the coroutine are stacked, and resumes always resume  
to the top-most invocation of a coroutine.  
.it 
Recording references to different invocations of coroutines 
is the responsibility of the programmer, and resumes are to a variable  
of a special type, through which the desired invocation may be accessed.
.le 
.ds 
There are advantages and disadvantages to these schema. 
.pb 
In the first, a situation comes readily to mind where the programmer most   

definitely does not wish to resume to the top-most on a stack of
coroutines. 
Suppose that a programmer is designing a compiler, using coroutines.
Suppose further that two separate sections of the compiler are invoked. 
Let each of these two sections invoke some routine - perhaps an error   
handler.
If section 1 calls the error handler first, and the error handler resumes   
to section 1, and then section 2 calls the error handler, which resumes to  
section 2, then when section 1 later resumes the error handler, it  
will resume the error handler which section 2 called, and not its own.  
Clearly, this is not a trivial problem, and can only be solved by   
identifying each coroutine invocation uniquely, in some way.
.pb 
The second choice also has problems associated with it. 
If the subject language is typed, we could define a special new type
of variable, references to which could be utilised to identify  
coroutine invocations uniquely. 
If the use of this type of variable were not carefully defined, 
certain major problems could arise, of the same type generated  
by runtime memory allocation (such as records in ALGOL-W, and   
getvec's in B). 
One could easily imagine the production of 'dangling coroutines',   
akin to 'dangling references'.  
However, this could be avoided by defining the use of such  
variables very carefully - they would only be allowed in coroutine  
calls and resumes, and nowhere else.
Assignment between such variables would be disallowed;  
thus, if a coroutine invocation were destroyed (through a return),  
the related variable could be nulled out, and so on.
.pb 
This solution unfortunately does not extend to typeless languages,  
such as B and BCPL, since it depends on being able to isolate   
the use of coroutine references through the type of the reference   
variable.   
In these languages the production   
of dangling coroutines is all too easy. 
.pb 
Thus, the way that coroutines are implemented is clearly dependent  
on the subject language and on the tastes of the implementer/user.  
.pb 
Normally, languages which allow recursion make use of a stack to refer  
to local variables. 
This stack is a contiguous block of storage which is travelled up and   
down as procedures are invoked and are returned from.   
In a language with coroutines, however, this would not be possible, 
since a series of procedures might be invoked, followed by a series 
of resumes and finally, a return.   
In this way, the upper and lower parts of the stack would still be used,
but a section of the stack in the middle would be invalid.  
Thus, no single contiguous block of storage may be allocated for more than  
one procedure invocation.   
.pb 
If one were to use the 'most recent invocation' rule, a pointer to a chain  
of valid stacks for a procedure could be stored in some fixed point in  
memory, possibly in the second word of the code for a procedure.
If a procedure were called, this pointer could be updated to point to   
a new stack for the procedure, and the old one made part of the list.   
.pb 
A resume from the procedure would update this new stack to record the   
instruction counter, before actually departing the procedure.   
.pb 
If a return from the coroutine were requested, the same sequence of steps   
would be followed as would be for a resume, except that, in addition
this stack would be unlinked from the chain of stacks, and returned to  
free space. 
No new schemes for the handling of non-local variables need be used, since  
the introduction of coroutines in no way changes this environment.  
.pb 
The syntax would be that outlined in Pratt: 
.at (call)  
cccaaallllll
.en (call)  
.at (resm)  
rrreeesssuuummmeee  
.en (resm)  
.at (retn)  
rrreeetttuuurrrnnn  
.en (retn)  
.nf 
.ls1
.sp 
<coroutine call> ::= ^(call) <procedure name>   
<coroutine resume> ::= ^(resm) <procedure name> 
<coroutine return> ::= ^(retn)  
.ds 
.fi 
.pb 
One major problem remains.  
Suppose the coroutine which is called invokes a normal function or  
procedure.  
This procedure cannot use the stack associated with its caller, 
since there is a danger that further calls could be made, resulting 
in a function falling off the end of the stack - a bug which is 
.ne5
difficult to isolate..  
.fn 
.in 5   
.ti -5  
1 . It is for this very reason that B places its stack at a location
preceding the code for the main line programme. 
If the limits of the stack should be exceeded, then code, which will
presumably later be executed is written over.   
When control returns to this area later and execution is attempted, 
an illegal op or memory fault occurs,   n notipp

tipping the user off to bugs in the coding. 
.en 
This implies that each separate procedure invocation, whether or not
it is to be used as a coroutine, should be called as such.  
.pb 
In implementing the second solution, a new syntax would have to be  
adopted for typed languages.
Yet another solution, currently in use on the Honeywell (the B coroutine
package), is described in closing.  
.pb 
The following syntax is suggested:  
.at (coro)  
cccooorrrooouuutttiiinnneee   
.en (coro)  
.at (ref)   
rrreeefff 
.en (ref)   
.at (yldg)  
yyyiiieeellldddiiinnnggg
.en (yldg)  
.ls1
.nf 
.sp 
<corout ref id> ::= <id>
<corout ref id declaration> ::= ^(coro) ^(ref) <id list>
<corout call> ::= ^(call) <corout name> <arg list>  
                  ^(yldg) <corout ref id>   
<corout resume> ::= ^(resm) <corout ref id> 
<corout return> ::= ^(retn) 
.fi 
.ds 
It will be observed that a coroutine call has a special syntax: 
the addition of a ^(yldg) clause.   
.pb 
Normally, when one invokes a function, in order to assign the result
to a variable, this result is not assigned to the variable until the
call is complete.   

Therefore, it would be inconsistent here to talk about 'assigning' a
coroutine reference name to a variable. 
Here, the coroutine reference is created, and this reference is recorded
immediately in the variable in the ^(yldg) field.   
.pb 
As described above, problems exist with regard to falling off the end of
the stack.  
The solution proposed above, that of making a fresh stack for every 
new procedure invocation, whether or not it is a coroutine, could also  
be applied here.
.pb 
Let us examine a particular example of coroutine implementation.
There is a coroutine package available on the Honeywell here for the B  
language.   
The implementor, T J Thompson, developed a number of basic functions
which allow the use of coroutines without changing the syntax of B. 
Since B is a typeless language, the problem of dangling coroutines certainly
arises. 
.pb 
The interesting aspect of Thompson's solution to the problem is 
that he wrote a set of functions which handle the creation, 
destruction, calling, resumption, and so on, of coroutines. 
He has thus remained entirely within the syntax of the B language.  
This might be regarded as 'cheating', however, since the routines were  


written in assembler language to simulate B functions.  
This is necessary, since in no other way could access to the workings   
of function calls be made.  
.pb 
To invoke a coroutine, one first creates it, then calls it: 
.nf 
.ls1
.sp 
  fcv = create( stacksize, info, function, arg1, arg2, ... );   
  call( fcv );  
.ds 
.fi 
The call to the function is set up by the create, which really produces 
a miniature stack for the use of the function.  
This is where 'stacksize' comes in - one may specify the size of the stack  
which one wishes the function to have.  
When that function is executed, it does not use the same stack as its invoker,  
but rather, the one set up by the 'create'. 
If the function should make a normal function call (ie. not to a coroutine),
that normal function would use this stack.  
This leads to one further danger - that the called function may fall off
the end of the stack, possibly resulting in the stack of another function   
being stepped on, and certainly resulting in an obscure bug.
Fortunately, B has both an excellent runtime, and a post-mortem, debugger,  
so that the knowledgeable user may find it easier to debug his/her programme.   
.pb 


As before, there is no problem with non-local environment references -  
all non-local references are to a fixed location in memory, meaning that
the proper accessing method is automatically the same as for the
normal, non-coroutine method.   
.pb 
In closing, let us say that there is no one 'way' that coroutines should
be implemented. 
The exact implementation depends very much on the design of other aspects   
of the language (typing), on the purpose of the language (a systems 
implementation language, such as B, must move very quickly when in  
production), and on the experience and taste of the implementer.
Clearly, the first solution to the problem (most recent invocation) 
would be preferred in a teaching environment, since it affords more 
protection to the unwary user.  
On the other hand, Thompson's solution to the problem was well chosen.  
Here he had to implement a coroutine package, but not in any way change 
the syntax of the language. 
He had to make do with what B provided him, but still provide a usable, 
useful, and fast set of routines to do it with. 
.h0 "Coroutines~and~Block-Structuring"  
.pb 
As mentioned in the introduction, the block structure of some languages 


has a wide-ranging effect on language implementation.   
Coroutines are no exception.
.h2 "A~Special~Coroutine~Typing:"   
.pb 
There are several reasons for specifying a coroutine type   
distinct from a conventional procedure type:
.sp 
.ls1
.in+5   
.ti-5   
1) Coroutines must not be function procedures.  
.br 
e.g. X := Y + COROUTINE(B) + Z  
.br 
If COROUTINE() does a RESUME back to this statement, it ought to return 
a value, which may be meaningless since it depends of where the routine does
its RESUME from.  It is likely unreasonable to require meaningful function  
values for every resume statement.  
.sp 
.ti-5   
2) Coroutines must not be passed as arguments to other procedures.  
Such an argument could be passed by a downward call from a higher lexic 
level to a lower, and then itself be CALLed.  This call would   
restore the environment of the passed procedure, effectively permitting 
a "resume" to the higher lexical level (not a RETURN, since the lower level 
procedure would not vanish on the CALL).  Once control was at the higher level, 
the conceptual chain of pointers down from this level to the main block would   , thbe altered by the presence of the new in


........
fass




be altered by the presence of the new invocation of the lower level procedure.  
.in-5   
.ds 
.h2 "Adherence~to~Standard~Format:" 
.pb 
The implementation of coroutines should not violate the standard
concepts of block structure, lexical level, and global/local environments.  
To this end it must be remembered that: 
.ls1
.in+5   
.sp 
.ti-5   
1) A procedure may only invoke (or RESUME) procedures which are defined 
immediately within or at the same or lower lexical level. (Scope Rules) 
.sp 
.ti-5   
2) Each procedure call creates a fresh copy of the invoked procedure,   
with all the attributes of its lexical level (i.e. global/local variables and   
procedures). Values of all local attributes are therefore undefined for the 
invoked procedure until themselves invoked (or assigned to, for variables). 
.sp 
.ti-5   
.ne5
.fn 
.ti-5   
. RETURN is functionally equivalent to a "GOTO <block-end>", causing
procedure return.   
.en 
3) RETURN. from an invoked procedure destroys that invocation of the
procedure and returns control to the invoker (the CALLer, for coroutines)   
regardless of the caller's lexical level.   
.sp 
.ti-5   y th4) Only the most recent 

4) Only the most recent invocation of a procedure is available and  
all references to the procedure refer to this current invocation.   
.ds 
.in-5   
.pb 
Conceptually, any references to variables global to the current block   
(i.e. non-local variables) are to be made through pointers in the display   
for this block. Local identifiers are created anew with each block entry
and hence can be allocated directly on the local stack. 
(Local stack space and space for the current block's display must be
allocated dynamically from free core, since with coroutines procedures tend 
to come and go "out of order", and a stack would not work. This, unfortunately, 
results in the need for some form of memory manager to keep track of active 
routines.)  
Local variable references are in fact made via <base of current local stack>
+ <offset of local variable>.   
Procedures which are formal parameters are called by making 
an indirect reference to the procedure, using the argument  
passed on the stack, which contains the address of the code for the procedure,  
plus the address of the display currently valid for that procedure. 
.pb 
We suggest that this means of conceptualization introduced by Pratt 

be extended.
As he says, the addresses of procedures are not actually maintained 
on the stack, but are known at compile time, and thus may be directly   
used.   
.pb 
However, if we wish to use coroutines,  
the entire local environment of a procedure must be saved when  
we execute a RESUME to leave it temporarily.
This means that a pointer to the stack for a procedure must 
be kept somewhere.  
.pb 
Following the lead suggested above, we could store the pointer  
on the stack of the procedure or block which is immediately below   
the invoked procedure.  
(Note: below means nesting, here; thus, the mainline of a programme 
is immediately below procedures declared in it.)
Since this procedure already contains a pointer to the  
.ul 
last
invocation of the contained procedure, this last invocation must be 
chained off" from the newer invocation such that a pointer to the newer invocation replaces 
the old.
.pb 
Using this method, to call a procedure, we would create a new   
stack for it, store the pointer to this stack in the appropriate
place, place the arguments on the stack and then branch to the  
beginning of the procedure. 
The display which the procedure would inherit and retain throughout 
its life would be that of the most recent invocation of the 
block enclosing it. 
On resuming another procedure from this one, we would access the
stack of that other procedure as above, store the address at which  
execution is to resume (when we again resume this procedure) in the 
stack for this procedure, and then transfer control to  the other procedure.
.pb 
When a CALLed coroutine returns for good (and dies), the chain of invocations   
of this procedure (stored, as mentioned, in it's immediately enclosing block)   
is shortened by one link, restoring the pointer to the previous invocation of   
this procedure.  In this way references to a procedure are always made by the   
same lexic level and offset pair (as in standard ALGOL); however this location  
always points to the most recent invocation of the procedure by having older
invocation pointers chained out of the way. 
It is logical to treat the flow of control in a coroutine   
as being local to it, and thus to store the resume address  
on the stack of the coroutine as it is being exited.
.h2 "Calls~to~Lower~Lexical~Levels:"
.pb 
Note the case of coroutine C nested in B nested in A.  If A calls B which   
calls C, and then C calls back to A, the call to A creates a NEW invocation 
of A which, at its lexical level, does not provide for or know about who
CALLed it.  It is impossible to attempt to RESUME C from A, since for A, C is   
an unknown procedure local to B.
To attempt to RESUME B from A would not work either since, although B is a  
defined procedure for A it is a 
.ul 
local   
procedure to A and hence appears uninvoked  
when A is created anew by the call from C!  
In short, CALLs to coroutines at lower lexical  
levels can only RETURN to their CALLers, never RESUME.  
.bp 
.h0 "Bibliography"  
.sp3
.ls1
.in+5   
.bb 
Dahl, O, and Nygaard, K, "Basic Concepts of Simula, an Algol Based  
Simulation Language", in Digital Simulation in Operational Research 
(S H Hollingdale, ed.), American Elsevier Publishing Co., 1967, pp116-124.  
.bb 
Dahl, O, and Nygaard, K, "Simula - an Algol Based   
Simulation Language", Comm. ACM,9,9,671-678.
.bb 
Pratt, "Comparative Programming Languages" (class text) 
