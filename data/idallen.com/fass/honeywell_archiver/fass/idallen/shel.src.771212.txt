


........
fass























/*  
!b -n fass/idallen/shel.src h=fass/idallen/shell s=50 l=tjthompson/lib  
*/  


EDIT = 1;	/* edit mode indicated by ed_or_mod == 1 */   
NUMCMDS = 40;	/* number of commands permitted to be stored */   


mprompt {"mod ? "};	/* prompt issued for a modify */
eprompt {"edi ? "};	/* prompt issued for an edit */ 
prompt[10] {'% *0*0'};	/* buffer to hold standard prompt */ 
inbuf0[32] {'-h*0*0'};	/* series of 4 input buffers, which are rotated */   
inbuf1[32] {'-h*0*0'};	/* so that the previous 3 commands are available */  
inbuf2[32] {'-h*0*0'};  
inbuf3[32] {'-h*0*0'};  
inbuf[4];	/* this will contain the addresses of the above 4 buffers */  
wkbuf0[32];	/* three work buffers for use in expanding commands */  
wkbuf1[32]; 
wkbuf2[32]; 
	/* cmdname holds all the 3-char command names */   
cmdname[NUMCMDS] {'***0*0*0','**-*0*0','**--*0','pro*0','h*0*0*0','cru*0',0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
cmdtext[NUMCMDS];	/* these are the texts for the corresponding command names */ 
inbufindx;	/* an index to tally character position in the current input buffer */   

inbufptr;	/* this points to the current input buffer: inbuf[n] */   
inbuflen;	/* length of the text in the current input buffer */  
edbuflen;	/* length of the text in the buffer to be edited */   


main(){ 
	extrn .ireq,.npigs,prompt,eprompt,mprompt,cmdname,cmdtext,inbuf,inbufindx; 
	extrn wkbuf0,wkbuf1,wkbuf2,inbufptr,edbuflen,inbuflen,inbuf0,inbuf1,inbuf2,inbuf3; 
	auto arg,dash_flag,b,c,edptr,pptr,ed_or_mod,newed_or_mod;  
	auto cmdtally,buf1tally,buf0tally,inbuftally,cmdptr,buf1len;   


	intrequest();  
	putstr("*rupdated Nov 11, 77 - type *"-h*"*n");
	inbuf[0] = inbuf0;	/* assign input buffers to matrix vector */ 
	inbuf[1] = inbuf1; 
	inbuf[2] = inbuf2; 
	inbuf[3] = inbuf3; 
	inbufptr = rotbufs();	/* rotate the input buffers and get a pointer to the oldest buffer */
	cmdtext[3] = prompt;	/* assign the address of the prompt string to the 'pro' cmdname */
	concat(cmdtext[4] = getvec(32),"p idallen/shel.exp");  
	ed_or_mod = 0;	/* the shell starts in normal mode: edit == 1, modify == 2, normal == 0 */  
	system(concat(cmdtext[5] = getvec(32),"crun sh.init.;**null"));	/* crun the init file into shell */


	repeat {   


		.ireq = 0;

ints		if(ed_or_mod){	/* 

		if(ed_or_mod){	/* must display the text to be edited or modified */   
			putstr(pptr = ((ed_or_mod == EDIT) ? eprompt : mprompt));
			putstr(edptr);   
			putchar('*n');   
		} 
		else pptr = prompt;   


		putchar('*r');
		putstr(pptr);	/* pptr points to the right prompt string */


		for(inbuflen = 0; (arg = getchar()) != '*n';){	/* this gets characters from the terminal, backspace is delete */  
			if(arg == '*b') {if(inbuflen) --inbuflen;}   
			else lchar(inbufptr,inbuflen++,arg); 
		} 
		lchar(inbufptr,inbuflen,'*0');


		if(.ireq || !inbuflen){ed_or_mod = 0; next;}  


		if(char(inbufptr,inbuflen - 1) == '?'){	/* test for edit/modify on end of line */ 
			if(char(inbufptr,inbuflen - 2) == '?'){	/* if true, must be a modify request on the line */  
				newed_or_mod = 2;   
				--inbuflen; 
			}
			else newed_or_mod = 1;	/* otherwise, must be an edit request on the line */  
			lchar(inbufptr,--inbuflen,'*0');	/* deletes '?'s at end of line */   
			if(!ed_or_mod){	/* if not under an edit or modify already, rotate input buffer into position */  
				inbufptr = rotbufs();   l */				edptr = cmdtext[0];	/* set the pointer to the edit buffer to point to the la

				edptr = cmdtext[0];	/* set the pointer to the edit buffer to point to the last command entered */   
			}
		} 
		else newed_or_mod = 0;


		if(ed_or_mod){
			edbuflen = length(edptr);	/* get the length of the buffer to be edited */
			while(char(edptr,--edbuflen) == ' ');
			lchar(edptr,++edbuflen,'*0');	/* delete trailing blanks */   


			if(ed_or_mod == EDIT) edit.(edptr);  
			else modify.(edptr); 
			ed_or_mod = newed_or_mod;	/* having done the edit, see if the editing line requested more edit */
			next;
		} 


		if(ed_or_mod = newed_or_mod) next;	/* assign new edit status */   
		dash_flag = 0;	/* so far, not a dash command */   


	rpt:	switch(char(inbufptr,0)){ 
			case '-':	/* indicates a dash command */ 
				if(char(inbufptr,1) == '*0'){	/* just print commands */ 
					putstr("Commands:*n*n");   
					for(arg = 0; arg < NUMCMDS; ++arg) if(cmdname[arg]){   
						putstr(&cmdname[arg]); putchar(' = '); putstr(cmdtext[arg]); putchar('*n');   
					}  
					next;  
				}   
				inbuftally = scan(wkbuf1,inbufptr,1," =");	/* otherwise get the argument following the dash */  
				lchar(wkbuf1,3,'*0');	/* make sure arg is 3 chars or less */
				lowerc(wkbuf1);	/* set lower case only */   
				for(b = 0; (b < NUMCMDS) && !equal(&cmdname[b],wkbuf1); ++b);	/* set b to the table position of the command, if found */
				if(char(inbufptr,inbuftally) == '='){	/* see if we stopped scan on an '=' */
					if(char(inbufptr,++inbuftally) == '*0'){	/* if '=' followed by null, release command */
						if((b != NUMCMDS) && (b > 3)){
							rlsevec(cmdtext[b],32);  
							cmdname[b] = 0;  
							putchar('rls*n');
						} 
						next; 
					}  
					if(b == NUMCMDS){	/* otherwise must be an assignment: see if space is available */ 
						for(b = 0; (b < NUMCMDS) && cmdname[b]; ++b); 
						if(b == NUMCMDS) {putstr("too many commands*n"); next;}   
						cmdtext[b] = getvec(32);	/* get space for the command */  
						cmdname[b] = wkbuf1[0];	/* copy the name of the command over */   
					}  
					for(c = 0; lchar(cmdtext[b],c++,char(inbufptr,inbuftally + c)) != '*0';);	/* copy command */   
					next;  
				}	/* not assignment - must find and execute */  
				if(b == NUMCMDS){putchar('??*n'); next;}	/* command not found */


				cmdptr = cmdtext[b];
				dash_flag = 1;	/* indicates command is dash command */  

 les				if(b < 4

				if(b < 4) inbuflen = length(concat(inbufptr,cmdptr));   
				else {  
					for(cmdtally = buf0tally = 0; (arg = char(cmdptr,cmdtally)) != '*0'; ++cmdtally){  
						if(arg == '&'){	/* copy argument from inbuffer */ 
							inbuftally = scan(wkbuf1,inbufptr,inbuftally," ");   
							copych(wkbuf0,buf0tally,wkbuf1,0,c = length(wkbuf1));
							buf0tally += c;  
						} 
						else lchar(wkbuf0,buf0tally++,arg);	/* copy a character */
					}  
					if(++inbuftally < inbuflen) copych(wkbuf0,buf0tally,inbufptr,inbuftally,(inbuflen - inbuftally) + 1);  
					else lchar(wkbuf0,buf0tally,'*0'); 
					inbuflen = length(concat(inbufptr,wkbuf0));
				}   
				goto rpt;   
			case '\':
				inbufptr = concat(wkbuf0,"qed r",inbufptr); 
				lchar(inbufptr,5,' ');  
				break;  
			case '?':	/* edit or modify any command text buffer */   
				ed_or_mod = (char(inbufptr,1) == '?') ? 2 : 1;  
				copych(&arg,0,inbufptr,ed_or_mod,3);	/* get name of text to edit */ 
				lchar(&arg,3,'*0'); 
				if(edptr = search(arg)) next;	/* search for the argument following the '?'s */  
				ed_or_mod = 0;	/* if not found, reset the edit/modify switch */ 
				next;   
		} 


		for(buf0tally = bu

		for(buf0tally = buf1tally = 0; (arg = char(inbufptr,buf0tally)) != '*0'; ++buf0tally){
			if(arg == '&'){	/* search for text and insert */ 
				if((c = char(inbufptr,buf0tally + 1)) == ' ' || (c == '.')) goto pas;   
				++buf0tally;
				if(c == '&') goto pas;  
				buf0tally = scan(wkbuf2,inbufptr,buf0tally,". ");   
				if(char(inbufptr,buf0tally) != '.') --buf0tally;
				lchar(wkbuf2,3,'*0');   
				if(arg = search(wkbuf2[0])) {   
					copych(wkbuf1,buf1tally,arg,0,c = length(arg));
					buf1tally += c;
				}   
				else lchar(wkbuf1,buf1tally++,' '); 
			}
			else	pas:	lchar(wkbuf1,buf1tally++,arg); 
		} 
		lchar(wkbuf1,buf1tally,'*0'); 


		if((arg = wkbuf1[0]) == 'quit') exit();   
		if(arg == 'qqqq'){
			putchar('bye*f');
			drl.drl(043);
		} 
		system(wkbuf1);   
		if(!dash_flag || (b > 3)) inbufptr = rotbufs();   
	}  
}   


rotbufs() { 
	extrn inbuf,inbufindx,cmdtext,inbufptr;


	cmdtext[0] = inbuf[inbufindx]; 
	cmdtext[1] = inbuf[decindx()]; 
	cmdtext[2] = inbuf[decindx()]; 
	return(inbuf[decindx()]);  
}   


decindx(){  
	extrn inbufindx;   


	if(inbufindx) return(--inbufindx); 
	else return(inbufindx = 3);
}   


edit.(buffer) { 
	auto b,arg;
	extrn inbufptr,edbuflen;   


	for(b = -1;(arg = char(inbufptr,++b)) != '*0';){   
		switch(arg){  
			case ' ':
				if(b < edbuflen) next;  
				break;  
			case '^':
				arg = ' ';  
		} 
		lchar(buffer,b,arg);  
	}  
	if(b > edbuflen) lchar(buffer,b,'*0'); 
}   


modify.(buffer) {   
	auto b,c,e,arg,m;  
	extrn inbufptr,wkbuf0,edbuflen,inbuflen;   


	for(e = m = b = 0;(arg = char(inbufptr,b++)) != '*0';){
		switch(arg){  
			case 'i':
			case 'I':
			case 'r':
			case 'R':
				copych(wkbuf0,m,inbufptr,b,c = inbuflen - b);   
				b = c;  
				if((arg == 'I') || (arg == 'i')) copych(wkbuf0,m += c,buffer,e,b = edbuflen - e);   
				m += b; 
				b = inbuflen;   
				e = edbuflen;   
				next;   
			case 'd':
			case 'D':
				if(e < edbuflen) ++e;   
				next;   
			case ' ':
				if(e < edbuflen) arg = char(buffer,e++);
				break;  
			case '^':
				if(e < edbuflen) ++e;   
				arg = ' ';  
				break;  
			default: 
				if(e < edbuflen) ++e;   
		} 
		lchar(wkbuf0,m++,arg);
	}  
	copych(wkbuf0,m,buffer,e,(edbuflen - e) + 1);  
	concat(buffer,wkbuf0); 
}   


search(arg){
	auto x;
	extrn cmdname,cmdtext; 


	for(x = 0; (x < NUMCMDS) && !equal(&cmdname[x],&arg); ++x);
	if(x == NUMCMDS) return(0);
	return(cmdtext[x]);
}   
