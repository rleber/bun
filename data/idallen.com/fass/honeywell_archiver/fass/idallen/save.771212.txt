


........
fass























/*  
!b -n fass/idallen/save h=fass/idallen/shell2 s=70 l=tjthompson/lib 
*/  


EDIT = 1;	/* edit mode indicated by ed_or_mod == 1 */   
NUMCMDS = 40;	/* number of commands permitted to be stored */   


mprompt {"mod ? "};	/* prompt issued for a modify */
eprompt {"edi ? "};	/* prompt issued for an edit */ 
	/* cmdname holds all the 3-char command names */   
cmdname[NUMCMDS] {'***0*0*0','**-*0*0','**--*0','pro*0','h*0*0*0','cru*0',0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
cmdtext[NUMCMDS];	/* these are the texts for the corresponding command names */ 
inbufindx;	/* an index to tally character position in the current input buffer */   
inbufroot;	/* root of all input buffers given by getmatrix */   
inbufptr;	/* this points to the current input buffer: inbuf[n] */   
inbuflen;	/* length of the text in the current input buffer */  
edbuflen;	/* length of the text in the buffer to be edited */   


main(){ 
	extrn .ireq,.npigs,eprompt,mprompt,cmdname,cmdtext;
	extrn inbufindx,inbufptr,edbuflen,inbuflen,inbufroot;  
	auto arg,prompt,dash_flag,b,c,edptr,pptr,ed_or_mod,newed_or_mod;   

	auto cmdtally,buf1tally,buf0tally,inbuftally,cmdptr,buf1len;   
	auto wkbuf0,wkbuf1,wkbuf2; 


	intrequest();  
	putstr("*rupdated Nov 11, 77 - type *"-h*"*n");
	ed_or_mod = 0;	/* the shell starts in normal mode: edit == 1, modify == 2, normal == 0 */  
	inbufroot = getmatrix(4,32);	/* get 4 input buffers */ 
	inbufptr = rotbufs();	/* rotate the input buffers and get a pointer to the oldest buffer */
	wkbuf0 = getmatrix(3,32);	/* get 3 work buffers */ 
	wkbuf1 = wkbuf0[1];
	wkbuf2 = wkbuf0[2];
	concat(prompt = cmdtext[3] = getvec(10),"% "); 
	concat(cmdtext[4] = getvec(32),"p idallen/shel.exp");  
	system(concat(cmdtext[5] = getvec(32),"crun sh.init.;**null"));	/* crun the init file into shell */


	repeat {   


		.ireq = 0;


		if(ed_or_mod){	/* must display the text to be edited or modified */   
			putstr(pptr = ((ed_or_mod == EDIT) ? eprompt : mprompt));
			putstr(edptr);   
			putchar('*n');   
		} 
		else pptr = prompt;   


		putchar('*r');
		putstr(pptr);	/* pptr points to the right prompt string */


		for(inbuflen = 0; (arg = getchar()) != '*n';){	/* this gets characters from the terminal, backspace is delete */  
			if(arg == '*b') {if(inbuflen) --inbuflen;}   
			else lchar(inbufptr,inbuflen++,arg); 
		} 
		lchar(inbufptr,inbuflen,'*0');


		if(.ireq || !inbuflen){ed_or_mod = 0; next;}  


		if(char(inbufptr,inbuflen - 1) == '?'){	/* test for edit/modify on end of line */ 
			if(char(inbufptr,inbuflen - 2) == '?'){	/* if true, must be a modify request on the line */  
				newed_or_mod = 2;   
				--inbuflen; 
			}
			else newed_or_mod = 1;	/* otherwise, must be an edit request on the line */  
			lchar(inbufptr,--inbuflen,'*0');	/* deletes '?'s at end of line */   
			if(!ed_or_mod){	/* if not under an edit or modify already, rotate input buffer into position */  
				inbufptr = rotbufs();   
				edptr = cmdtext[0];	/* set the pointer to the edit buffer to point to the last command entered */   
			}
		} 
		else newed_or_mod = 0;


		if(ed_or_mod){
			edbuflen = length(edptr);	/* get the length of the buffer to be edited */
			while(char(edptr,--edbuflen) == ' ');
			lchar(edptr,++edbuflen,'*0');	/* delete trailing blanks */   


			if(ed_or_mod == EDIT) edit.(edptr);  
			else modify.(edptr); 
			ed_or_mod = newed_or_mod;	/* having done the edit, see if the editing line requested more edit */
			next;
		} 


		if(ed_or_mod = newed_or_mod) next;	/* assign new edit status */   
		dash_flag = 0;	/* so far, not a dash command */   


	rpt:	switch(char(inbufptr,0)){ 
			case '-':	/* indicates a dash command */ 
				if(char(inbufptr,1) == '*0'){	/* just print commands */ 
					putstr("Commands:*n*n");   
					for(arg = 0; arg < NUMCMDS; ++arg) if(cmdname[arg]){   
						putstr(&cmdname[arg]); putchar(' = '); putstr(cmdtext[arg]); putchar('*n');   
					}  
					next;  
				}   
				inbuftally = scan(wkbuf1,inbufptr,1," =");	/* otherwise get the argument following the dash */  
				lchar(wkbuf1,3,'*0');	/* make sure the argument is 3 chars or less */   
				for(b = 0; (b < NUMCMDS) && !equal(&cmdname[b],wkbuf1); ++b);	/* set b to the table position of the command, if found */
				if(char(inbufptr,inbuftally) == '='){	/* see if we stopped scan on an '=' */
					if(char(inbufptr,++inbuftally) == '*0'){	/* if '=' followed by null, release command */
						if((b != NUMCMDS) && (b > 3)){
							rlsevec(cmdtext[b],32);  
							cmdname[b] = 0;  
							putchar('rls*n');
						} 
						next; 
					}  
					if(b == NUMCMDS){	/* otherwise must be an assignment: see if space is available */ 
						for(b = 0; (b < NUMCMDS) && cmdname[b]; ++b); 
						if(b == NUMCMDS) {putstr("too many commands*n"); next;}   
						cmdtext[b] = getvec(32);	/* get space for the command */  
						cmdname[b] = wkbuf1[0];	/* copy the name of the command over */   
					}  
					for(c = 0; lchar(cmdtext[b],c++,char(inbufptr,inbuftally + c)) != '*0';);	/* copy command */   
					next;  
				}	/* not assignment - must find and execute */  
				if(b == NUMCMDS){putchar('??*n'); next;}	/* command not found */


				cmdptr = cmdtext[b];
				dash_flag = 1;	/* indicates command is dash command */  


				if(b < 4) inbuflen = length(concat(inbufptr,cmdptr));   
				else {  
					for(cmdtally = buf0tally = 0; (arg = char(cmdptr,cmdtally)) != '*0'; ++cmdtally){  
						if(arg == '&'){	/* copy argument from inbuffer */ 
							inbuftally = scan(wkbuf1,inbufptr,inbuftally," ");   
							copych(wkbuf0,buf0tally,wkbuf1,0,c = length(wkbuf1));
							buf0tally += c;  
						} 
						else lchar(wkbuf0,buf0tally++,arg);	/* copy a character */
					}  
					if(++inbuftally < inbuflen) copych(wkbuf0,buf0tally,inbufptr,inbuftally,(inbuflen - inbuftally) + 1);  
					else lchar(wkbuf0,buf0tally,'*0'); 
					inbuflen = length(concat(inbufptr,wkbuf0));
				}   
				goto rpt;   
			case '\':
				inbufptr = concat(wkbuf0,"qed r",inbufptr); 
				lchar(inbufptr,5,' ');  
				break;  
			case '?':	/* edit or modify any command text buffer */   
				ed_or_mod = (char(inbufptr,1) == '?') ? 2 : 1;  
				copych(&arg,0,inbufptr,ed_or_mod,3);	/* get name of text to edit */ 
				lchar(&arg,3,'*0'); 
				if(edptr = search(arg)) next;	/* search for the argument following the '?'s */  
				ed_or_mod = 0;	/* if not found, reset the edit/modify switch */ 
				next;   
			case 'q':	/* may be quit? */ 
				if((arg = inbufptr[0]) == 'quit') exit();   
				if(arg == 'qqqq'){  
					putchar('bye*f');  
					drl.drl(043);  
				}   
		} 


		for(buf0tally = buf1tally = 0; (arg = char(inbufptr,buf0tally)) != '*0'; ++buf0tally){
			if(arg == '&'){	/* search for text and insert */ 
				if((c = char(inbufptr,buf0tally + 1)) == ' ' || (c == '.')) goto pas;   
				++buf0tally;
				if(c == '&') goto pas;  
				buf0tally = scan(wkbuf2,inbufptr,buf0tally,". ");   
				if(char(inbufptr,buf0tally) != '.') --buf0tally;
				lchar(wkbuf2,3,'*0');   
				if(arg = search(wkbuf2[0])) {   
					copych(wkbuf1,buf1tally,arg,0,c = length(arg));
					buf1tally += c;
				}   
				else lchar(wkbuf1,buf1tally++,' '); 
			}
			else	pas:	lchar(wkbuf1,buf1tally++,arg); 
		} 
		lchar(wkbuf1,buf1tally,'*0'); 


		system(wkbuf1);   
		if(!dash_flag || (b > 3)) inbufptr = rotbufs();   
	}  
}   


rotbufs() { 
	extrn inbufindx,cmdtext,inbufroot; 


	cmdtext[0] = inbufroot[inbufindx]; 
	cmdtext[1] = inbufroot[decindx()]; 
	cmdtext[2] = inbufroot[decindx()]; 
	return(inbufroot[decindx()]);  
}   


decindx(){  
	extrn inbufindx;   


	if(inbufindx) return(--inbufindx); 
	else return(inbufindx = 3);
}   


edit.(buffer) { 
	auto b,arg;
	extrn inbufptr,edbuflen;   


	for(b = -1;(arg = char(inbufptr,++b)) != '*0';){   
		switch(arg){  
			case ' ':
				if(b < edbuflen) next;  
				break;  
			case '^':
				arg = ' ';  
		} 
		lchar(buffer,b,arg);  
	}  
	if(b > edbuflen) lchar(buffer,b,'*0'); 
}   

inbumodify.(

modify.(buffer) {   
	auto b,c,e,arg,m,wkbuffer[32]; 
	extrn inbufptr,edbuflen,inbuflen;  


	for(e = m = b = 0;(arg = char(inbufptr,b++)) != '*0';){
		switch(arg){  
			case 'i':
			case 'I':
			case 'r':
			case 'R':
				copych(wkbuffer,m,inbufptr,b,c = inbuflen - b); 
				b = c;  
				if((arg == 'I') || (arg == 'i')) copych(wkbuffer,m += c,buffer,e,b = edbuflen - e); 
				m += b; 
				b = inbuflen;   
				e = edbuflen;   
				next;   
			case 'd':
			case 'D':
				if(e < edbuflen) ++e;   
				next;   
			case ' ':
				if(e < edbuflen) arg = char(buffer,e++);
				break;  
			case '^':
				if(e < edbuflen) ++e;   
				arg = ' ';  
				break;  
			default: 
				if(e < edbuflen) ++e;   
		} 
		lchar(wkbuffer,m++,arg);  
	}  
	copych(wkbuffer,m,buffer,e,(edbuflen - e) + 1);
	concat(buffer,wkbuffer);   
}   


search(arg){
	auto x;
	extrn cmdname,cmdtext; 


	for(x = 0; (x < NUMCMDS) && !equal(&cmdname[x],&arg); ++x);
	if(x == NUMCMDS) return(0);
	return(cmdtext[x]);
}   
